Index: cpp/examples/MinOZW/Main.cpp
===================================================================
--- cpp/examples/MinOZW/Main.cpp	(revision 779)
+++ cpp/examples/MinOZW/Main.cpp	(working copy)
@@ -155,6 +155,7 @@
 			nodeInfo->m_nodeId = _notification->GetNodeId();
 			nodeInfo->m_polled = false;		
 			g_nodes.push_back( nodeInfo );
+			 Manager::Get()->AddAssociation(nodeInfo->m_homeId, nodeInfo->m_nodeId, 1, 1);
 			break;
 		}
 
@@ -261,11 +262,11 @@
 	// The first argument is the path to the config files (where the manufacturer_specific.xml file is located
 	// The second argument is the path for saved Z-Wave network state and the log file.  If you leave it NULL 
 	// the log file will appear in the program's working directory.
-	Options::Create( "../../../config/", "", "" );
+	Options::Create( "/etc/zwave/", "/var/zwave/", "" );
 	Options::Get()->AddOptionInt( "SaveLogLevel", LogLevel_Detail );
 	Options::Get()->AddOptionInt( "QueueLogLevel", LogLevel_Debug );
 	Options::Get()->AddOptionInt( "DumpTrigger", LogLevel_Error );
-	Options::Get()->AddOptionInt( "PollInterval", 500 );
+	Options::Get()->AddOptionInt( "PollInterval", 100 );
 	Options::Get()->AddOptionBool( "IntervalBetweenPolls", true );
 	Options::Get()->AddOptionBool("ValidateValueChanges", true);
 	Options::Get()->Lock();
@@ -314,7 +315,7 @@
 	if( !g_initFailed )
 	{
 
-		Manager::Get()->WriteConfig( g_homeId );
+//		Manager::Get()->WriteConfig( g_homeId );
 
 		// The section below demonstrates setting up polling for a variable.  In this simple
 		// example, it has been hardwired to poll COMMAND_CLASS_BASIC on the each node that 
@@ -332,13 +333,19 @@
 				ValueID v = *it2;
 				if( v.GetCommandClassId() == 0x20 )
 				{
-					Manager::Get()->EnablePoll( v, 2 );		// enables polling with "intensity" of 2, though this is irrelevant with only one value polled
+					Manager::Get()->EnablePoll( v, 1 );		// enables polling
 					break;
 				}
 			}
 		}
 		pthread_mutex_unlock( &g_criticalSection );
 
+		while(1)
+		{
+			sleep(1);
+		}
+
+/*
 		// If we want to access our NodeInfo list, that has been built from all the
 		// notification callbacks we received from the library, we have to do so
 		// from inside a Critical Section.  This is because the callbacks occur on other 
@@ -354,6 +361,7 @@
 			pthread_mutex_unlock( &g_criticalSection );
 			sleep(1);
 		}
+*/
 
 		Driver::DriverData data;
 		Manager::Get()->GetDriverStatistics( g_homeId, &data );
Index: cpp/examples/MinOZW/Makefile
===================================================================
--- cpp/examples/MinOZW/Makefile	(revision 779)
+++ cpp/examples/MinOZW/Makefile	(working copy)
@@ -20,7 +20,7 @@
 
 INCLUDES	:= -I $(top_srcdir)/cpp/src -I $(top_srcdir)/cpp/src/command_classes/ -I $(top_srcdir)/cpp/src/value_classes/ \
 	-I $(top_srcdir)/cpp/src/platform/ -I $(top_srcdir)/cpp/src/platform/unix -I $(top_srcdir)/cpp/tinyxml/ -I $(top_srcdir)/cpp/hidapi/hidapi/
-LIBS =  $(wildcard $(LIBDIR)/*.so $(top_builddir)/*.so $(top_builddir)/cpp/build/*.so )
+LIBS =  $(wildcard $(LIBDIR)/*.a $(top_builddir)/*.a $(top_builddir)/cpp/build/*.a )
 LIBSDIR = $(abspath $(dir $(firstword $(LIBS))))
 minozwsrc := $(notdir $(wildcard $(top_srcdir)/cpp/examples/MinOZW/*.cpp))
 VPATH := $(top_srcdir)/cpp/examples/MinOZW
@@ -40,7 +40,7 @@
 
 $(OBJDIR)/MinOZW:	$(patsubst %.cpp,$(OBJDIR)/%.o,$(minozwsrc))
 	@echo "Linking $(OBJDIR)/MinOZW"
-	$(LD) $(LDFLAGS) -o $@ $< $(LIBS) -pthread
+	$(LD) $(LDFLAGS) -static -o $@ $< $(LIBS) -ludev -lrt -pthread
 
 $(top_builddir)/MinOZW: $(top_srcdir)/cpp/examples/MinOZW/MinOZW.in $(OBJDIR)/MinOZW
 	@echo "Creating Temporary Shell Launch Script"
Index: cpp/src/platform/unix/LogImpl.cpp
===================================================================
--- cpp/src/platform/unix/LogImpl.cpp	(revision 779)
+++ cpp/src/platform/unix/LogImpl.cpp	(working copy)
@@ -53,14 +53,14 @@
 	m_queueLevel( _queueLevel ),				// level of messages to log to queue
 	m_dumpTrigger( _dumpTrigger )				// dump queued messages when this level is seen
 {
-	if ( !m_bAppendLog )
-	{
-		FILE* pFile = fopen( m_filename.c_str(), "w" );
-		if( pFile != NULL )
-		{
-			fclose( pFile );
-		}
-	}
+	// if ( !m_bAppendLog )
+	// {
+	// 	FILE* pFile = fopen( m_filename.c_str(), "w" );
+	// 	if( pFile != NULL )
+	// 	{
+	// 		fclose( pFile );
+	// 	}
+	// }
 	setlinebuf(stdout);	// To prevent buffering and lock contention issues
 }
 
@@ -109,16 +109,16 @@
 			char outBuf[1124];
 			char *outBufPtr = outBuf;
 			// save to file
-			FILE* pFile = fopen( m_filename.c_str(), "a" );
-			if ( pFile != NULL || m_bConsoleOutput )
-			{
-				if( _logLevel != LogLevel_Internal )						// don't add a second timestamp to display of queued messages
-				{
-					strcpy( outBufPtr, timeStr.c_str() );
-					outBufPtr += timeStr.length();
-					strcpy( outBufPtr, nodeStr.c_str() );
-					outBufPtr += nodeStr.length();
-				}
+			// FILE* pFile = fopen( m_filename.c_str(), "a" );
+			// if ( pFile != NULL || m_bConsoleOutput )
+			// {
+				// if( _logLevel != LogLevel_Internal )						// don't add a second timestamp to display of queued messages
+				// {
+				// 	strcpy( outBufPtr, timeStr.c_str() );
+				// 	outBufPtr += timeStr.length();
+				// 	strcpy( outBufPtr, nodeStr.c_str() );
+				// 	outBufPtr += nodeStr.length();
+				// }
 
 				if( lineLen > 0 )
 				{
@@ -135,16 +135,16 @@
 				*outBufPtr = '\0';
 
 				// print message to file (and possibly screen)
-				if( pFile != NULL )
-				{
-					fputs( outBuf, pFile );
-					fclose( pFile );
-				}
-				if( m_bConsoleOutput )
-				{
+				// if( pFile != NULL )
+				// {
+				// 	fputs( outBuf, pFile );
+				// 	fclose( pFile );
+				// }
+				// if( m_bConsoleOutput )
+				// {
 					fputs( outBuf, stdout );
-				}
-			}
+				// }
+			// }
 		}
 
 		if( _logLevel != LogLevel_Internal )
